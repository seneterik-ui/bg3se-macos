#!/usr/bin/env python3
"""
extract_typeids.py - Extract component TypeId addresses from macOS BG3 binary

Generates a C header file with all discovered TypeId addresses that can be
used to register components in BG3SE-macOS.

Usage:
    python3 tools/extract_typeids.py > generated_typeids.h

Or with custom binary path:
    python3 tools/extract_typeids.py /path/to/binary
"""

import subprocess
import re
import sys
from collections import defaultdict
from pathlib import Path

# Default binary path
DEFAULT_BINARY = "/Users/tomdimino/Library/Application Support/Steam/steamapps/common/Baldurs Gate 3/Baldur's Gate 3.app/Contents/MacOS/Baldur's Gate 3"

def extract_typeids(binary_path: str) -> dict:
    """Extract TypeId m_TypeIndex addresses from the binary."""

    # Run nm and c++filt
    cmd = f'nm -gU "{binary_path}" 2>/dev/null | c++filt'
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

    if result.returncode != 0:
        print(f"Error running nm: {result.stderr}", file=sys.stderr)
        return {}

    # Pattern to match TypeId entries with ComponentTypeIdContext
    # Format: ADDRESS D ls::TypeId<COMPONENT, ecs::ComponentTypeIdContext>::m_TypeIndex
    pattern = re.compile(
        r'^([0-9a-f]+)\s+D\s+ls::TypeId<([^,]+),\s*ecs::ComponentTypeIdContext>::m_TypeIndex$'
    )

    components = {}

    for line in result.stdout.splitlines():
        # Skip guard variables
        if 'guard variable' in line:
            continue

        match = pattern.match(line)
        if match:
            address = int(match.group(1), 16)
            component_name = match.group(2).strip()

            # Skip non-component types
            if 'Component' not in component_name:
                continue

            components[component_name] = address

    return components

def categorize_components(components: dict) -> dict:
    """Categorize components by namespace."""
    categories = defaultdict(list)

    for name, addr in sorted(components.items()):
        # Extract namespace
        if '::' in name:
            ns = name.split('::')[0]
        else:
            ns = 'global'

        categories[ns].append((name, addr))

    return categories

def generate_header(components: dict) -> str:
    """Generate C header file with TypeId addresses for ALL components."""

    categories = categorize_components(components)

    lines = []
    lines.append("/**")
    lines.append(" * generated_typeids.h - Auto-generated TypeId addresses")
    lines.append(" *")
    lines.append(" * Generated by tools/extract_typeids.py")
    lines.append(f" * Total components: {len(components)}")
    lines.append(" *")
    lines.append(" * NOTE: These are Ghidra addresses. To get runtime addresses:")
    lines.append(" *   runtime_addr = ghidra_addr - 0x100000000 + binary_base")
    lines.append(" */")
    lines.append("")
    lines.append("#ifndef GENERATED_TYPEIDS_H")
    lines.append("#define GENERATED_TYPEIDS_H")
    lines.append("")
    lines.append("#include <stdint.h>")
    lines.append("")

    # Statistics
    lines.append("// === Statistics ===")
    lines.append(f"// Total components: {len(components)}")
    for ns, comps in sorted(categories.items()):
        lines.append(f"// {ns}:: namespace: {len(comps)} components")
    lines.append("")

    # Generate ALL namespaces
    for ns, ns_components in sorted(categories.items(), key=lambda x: -len(x[1])):
        lines.append(f"// ============================================================================")
        lines.append(f"// {ns.upper()}:: NAMESPACE ({len(ns_components)} components)")
        lines.append(f"// ============================================================================")
        lines.append("")

        # Group by sub-namespace
        groups = defaultdict(list)
        for name, addr in ns_components:
            parts = name.split('::')
            if len(parts) > 2:
                sub_ns = '::'.join(parts[:2])
            else:
                sub_ns = ns
            groups[sub_ns].append((name, addr))

        for sub_ns, comps in sorted(groups.items()):
            if sub_ns != ns:
                lines.append(f"// --- {sub_ns} ({len(comps)} components) ---")
            for name, addr in sorted(comps, key=lambda x: x[0]):
                # Create C-safe identifier
                c_name = name.replace('::', '_').upper()
                lines.append(f"#define TYPEID_{c_name} 0x{addr:x}ULL")
            lines.append("")

    lines.append("#endif // GENERATED_TYPEIDS_H")

    return '\n'.join(lines)

def generate_summary(components: dict):
    """Print summary statistics."""
    categories = categorize_components(components)

    print("// === Component TypeId Summary ===", file=sys.stderr)
    print(f"// Total: {len(components)} components with TypeId addresses", file=sys.stderr)
    print("//", file=sys.stderr)

    for ns, comps in sorted(categories.items(), key=lambda x: -len(x[1])):
        print(f"// {ns}:: - {len(comps)} components", file=sys.stderr)

    print("//", file=sys.stderr)
    print("// BG3SE-macOS currently implements 36 components (~1.8% coverage)", file=sys.stderr)
    print("// High-priority target: 100-150 eoc:: components (~5-7% coverage)", file=sys.stderr)

def generate_registration_code(components: dict) -> str:
    """Generate C code to register all components."""

    categories = categorize_components(components)

    lines = []
    lines.append("/**")
    lines.append(" * generated_component_registry.c - Auto-generated component registration")
    lines.append(" *")
    lines.append(" * Generated by tools/extract_typeids.py --registry")
    lines.append(f" * Total components: {len(components)}")
    lines.append(" */")
    lines.append("")
    lines.append('#include "component_registry.h"')
    lines.append('#include "generated_typeids.h"')
    lines.append('#include "../core/logging.h"')
    lines.append("")
    lines.append("// Component entry structure")
    lines.append("typedef struct {")
    lines.append("    const char *name;")
    lines.append("    uint64_t typeid_addr;")
    lines.append("} GeneratedComponentEntry;")
    lines.append("")

    # Generate array for each namespace
    for ns, ns_components in sorted(categories.items(), key=lambda x: -len(x[1])):
        lines.append(f"// {ns}:: namespace ({len(ns_components)} components)")
        lines.append(f"static const GeneratedComponentEntry g_{ns.capitalize()}Components[] = {{")

        for name, addr in sorted(ns_components, key=lambda x: x[0]):
            c_name = name.replace('::', '_').upper()
            lines.append(f'    {{ "{name}", TYPEID_{c_name} }},')

        lines.append("};")
        lines.append(f"#define {ns.upper()}_COMPONENT_COUNT {len(ns_components)}")
        lines.append("")

    # Generate master registration function
    lines.append("// Register all components from all namespaces")
    lines.append("void component_registry_register_all_generated(void) {")
    lines.append(f"    LOG_ENTITY_INFO(\"Registering {len(components)} generated components...\");")
    lines.append("")

    for ns, ns_components in sorted(categories.items(), key=lambda x: -len(x[1])):
        lines.append(f"    // {ns}:: namespace")
        lines.append(f"    for (int i = 0; i < {ns.upper()}_COMPONENT_COUNT; i++) {{")
        lines.append(f"        component_registry_register(")
        lines.append(f"            g_{ns.capitalize()}Components[i].name,")
        lines.append(f"            COMPONENT_INDEX_UNDEFINED,  // Index discovered at runtime")
        lines.append(f"            0,   // Size unknown until discovery")
        lines.append(f"            false  // Assume not proxy")
        lines.append(f"        );")
        lines.append(f"    }}")
        lines.append("")

    lines.append(f"    LOG_ENTITY_INFO(\"Registered {len(components)} components (TypeId-only, no property access yet)\");")
    lines.append("}")
    lines.append("")
    lines.append("// Get count of generated components")
    lines.append(f"int component_registry_generated_count(void) {{ return {len(components)}; }}")
    lines.append("")

    return '\n'.join(lines)

def main():
    import argparse

    parser = argparse.ArgumentParser(description="Extract component TypeId addresses from BG3 binary")
    parser.add_argument("binary", nargs="?", default=DEFAULT_BINARY, help="Path to BG3 binary")
    parser.add_argument("--registry", action="store_true", help="Generate registration C file instead of header")
    args = parser.parse_args()

    if not Path(args.binary).exists():
        print(f"Error: Binary not found at {args.binary}", file=sys.stderr)
        sys.exit(1)

    components = extract_typeids(args.binary)

    if not components:
        print("Error: No components found", file=sys.stderr)
        sys.exit(1)

    # Generate summary to stderr
    generate_summary(components)

    # Generate output to stdout
    if args.registry:
        print(generate_registration_code(components))
    else:
        print(generate_header(components))

if __name__ == "__main__":
    main()
