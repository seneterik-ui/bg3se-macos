# Integration Guide: Generated Component Layouts

This guide explains how to integrate the 176 generated component layouts into the BG3SE-macOS codebase.

## Quick Start

1. **Review generated layouts**: `/Users/tomdimino/Desktop/Programming/bg3se-macos/ghidra/offsets/staging/generated_eoc_layouts.c`
2. **Verify a sample in-game** (recommended)
3. **Copy verified layouts** to `src/entity/component_offsets.h`
4. **Register in g_AllComponentLayouts** array
5. **Test with Lua console**

## Step 1: In-Game Verification

Before integrating all layouts, verify a few key components work correctly:

### Example: Verify BaseHpComponent

```lua
-- In BG3 Lua console
local player = Ext.Entity.Get(Osi.GetHostCharacter())
local hp = player.BaseHp

-- Check fields exist and have reasonable values
_P("Vitality:", hp.Vitality)          -- Expected: 8-20 (level-dependent)
_P("VitalityBoost:", hp.VitalityBoost) -- Expected: 0 or positive

-- Verify the component size matches
-- BaseHpComponent should be 8 bytes (0x8)
-- With 2 int32_t fields at 0x00 and 0x04
```

### Example: Verify AbilityBoostComponent

```lua
-- Find entity with ability boost
local player = Ext.Entity.Get(Osi.GetHostCharacter())

-- Search for boost entities (they're separate entities)
-- This requires more complex traversal, but you can check:
local boosts = player.BoostsContainer
if boosts then
    _D(boosts.Boosts)  -- Will show boost entity handles

    -- For each boost, get the boost entity and check its type
    for _, boost in ipairs(boosts.Boosts) do
        local boostEntity = Ext.Entity.Get(boost.Boosts[1])
        if boostEntity.AbilityBoost then
            _D(boostEntity.AbilityBoost)
            -- Should show Ability (0-6 for STR/DEX/CON/INT/WIS/CHA)
            -- And Value (modifier amount)
        end
    end
end
```

## Step 2: Integration into component_offsets.h

### Add to the Header File

Open `/Users/tomdimino/Desktop/Programming/bg3se-macos/src/entity/component_offsets.h` and add verified layouts.

**Location**: After existing layouts, before the `g_AllComponentLayouts` array.

```c
// =============================================================================
// AUTO-GENERATED EOC:: COMPONENTS (Verified)
// Generated by generate_layouts.py from Windows BG3SE headers
// =============================================================================

// eoc::BaseHpComponent - 8 bytes (0x8)
// Source: BaseHpComponent from Windows BG3SE
static const ComponentPropertyDef g_eoc_BaseHpComponent_Properties[] = {
    { "Vitality", 0x00, FIELD_TYPE_INT32, 0, false },
    { "VitalityBoost", 0x04, FIELD_TYPE_INT32, 0, false },
};
static const ComponentLayoutDef g_eoc_BaseHpComponent_Layout = {
    .componentName = "eoc::BaseHpComponent",
    .shortName = "BaseHpComponent",
    .componentTypeIndex = 0,
    .componentSize = 0x8,
    .properties = g_eoc_BaseHpComponent_Properties,
    .propertyCount = sizeof(g_eoc_BaseHpComponent_Properties) / sizeof(g_eoc_BaseHpComponent_Properties[0]),
};

// ... add more verified components ...
```

### Register in g_AllComponentLayouts

Find the `g_AllComponentLayouts` array and add pointers to your new layouts:

```c
static const ComponentLayoutDef* g_AllComponentLayouts[] = {
    // ... existing layouts ...

    // Auto-generated eoc:: components
    &g_eoc_BaseHpComponent_Layout,
    &g_eoc_ArmorComponent_Layout,
    &g_eoc_AttributeFlagsComponent_Layout,
    &g_eoc_BackgroundComponent_Layout,
    // ... add all verified layouts ...

    NULL  // Keep sentinel
};
```

## Step 3: Bulk Integration Strategy

For integrating many components efficiently:

### Prioritize by Usage

1. **High priority** (commonly used in mods):
   - Health/vitality components (BaseHpComponent, HealthComponent)
   - Stat components (StatsComponent, BaseStatsComponent)
   - Equipment components (ArmorComponent, WeaponComponent)
   - Boost components (common gameplay modifiers)

2. **Medium priority**:
   - Inventory components
   - Spell components
   - Status components
   - Combat components

3. **Low priority**:
   - UI components
   - Character creation components
   - Debug/editor components

### Batch Verification Script

Create a Lua verification script to test multiple components:

```lua
-- Save as verify_components.lua
local function verifyComponent(entity, componentName, expectedFields)
    local comp = entity[componentName]
    if not comp then
        _PE("MISSING:", componentName)
        return false
    end

    for _, field in ipairs(expectedFields) do
        if comp[field] == nil then
            _PE("MISSING FIELD:", componentName .. "." .. field)
            return false
        end
    end

    _P("OK:", componentName)
    return true
end

local player = Ext.Entity.Get(Osi.GetHostCharacter())

-- Verify core components
verifyComponent(player, "BaseHp", {"Vitality", "VitalityBoost"})
verifyComponent(player, "AttributeFlags", {"AttributeFlags"})
verifyComponent(player, "Classes", {"Classes"})
verifyComponent(player, "Data", {"Weight", "StatsId"})
verifyComponent(player, "Level", {"Level"})

-- Verify equipment
local weapon = Ext.Entity.Get(player.Wielding.Weapon) -- if player has weapon
if weapon then
    verifyComponent(weapon, "Weapon", {})  -- Just check existence
    verifyComponent(weapon, "Value", {})
end

_P("Verification complete!")
```

## Step 4: Testing

After integration:

```bash
# Rebuild
cd build && cmake --build .

# Launch game
./scripts/launch_bg3.sh

# In Lua console, test individual components
local player = Ext.Entity.Get(Osi.GetHostCharacter())
_D(player.BaseHp)
_D(player.AttributeFlags)
_D(player.Classes)

# Test boost components (more complex)
-- Need to find boost entities via BoostsContainer
```

## Common Issues and Fixes

### Issue 1: Field Offset Mismatch

**Symptom**: Field values are garbage or incorrect

**Fix**: ARM64 struct padding may differ from Windows x64. Use runtime probing:

```lua
local typeId = 0x...  -- From component_typeid.c
local rawPtr = Ext.Entity.GetComponentRawPtr(player, typeId)
local probed = Ext.Debug.ProbeStruct(rawPtr, 0, 32, 4)
_D(probed)  -- Compare with generated offsets
```

### Issue 2: Component Size Mismatch

**Symptom**: Crashes or memory corruption

**Fix**: Verify component size from Ghidra matches generated size. Check COMPONENT_SIZES_EOC_*.md files.

### Issue 3: Wrong Field Type

**Symptom**: Field exists but has wrong type (e.g., number instead of GUID)

**Fix**: Check Windows header for actual field type. Enum types may need adjustment.

### Issue 4: Namespace Collision

**Symptom**: Multiple components with same shortName

**Fix**: Use full namespace in shortName for sub-namespaced components:
```c
.shortName = "spell_BookComponent",  // Instead of just "BookComponent"
```

## Performance Considerations

### Layout Registration

Each registered layout adds minimal overhead:
- ~200 bytes per layout in static data
- O(1) lookup once registered
- No runtime allocation

### Property Count

More properties = more fields exposed to Lua:
- Keep only useful fields
- Skip internal/debug fields if not needed
- Arrays count as single property

## Advanced: Adding Custom Fields

If you discover additional fields via reverse engineering:

```c
// Original generated layout
static const ComponentPropertyDef g_eoc_MyComponent_Properties[] = {
    { "Field1", 0x00, FIELD_TYPE_INT32, 0, false },
    // Generated offset: 0x04
};

// After Ghidra analysis, you find another field at 0x04
static const ComponentPropertyDef g_eoc_MyComponent_Properties[] = {
    { "Field1", 0x00, FIELD_TYPE_INT32, 0, false },
    { "Field2", 0x04, FIELD_TYPE_FLOAT, 0, false },  // Newly discovered
    { "Field3", 0x08, FIELD_TYPE_GUID, 0, false },   // Newly discovered
};

// Update component size if needed
static const ComponentLayoutDef g_eoc_MyComponent_Layout = {
    .componentSize = 0x18,  // Was 0x4, now 0x18
    // ... rest unchanged ...
};
```

## Validation Checklist

Before marking a layout as "verified":

- [ ] Component exists on expected entity types
- [ ] All fields are accessible from Lua
- [ ] Field values are reasonable (not garbage)
- [ ] Field types match expectations (number vs string vs table)
- [ ] Component size matches Ghidra measurement
- [ ] No crashes when accessing fields
- [ ] Works consistently across game restarts

## Example: Full Integration of BaseHpComponent

### 1. Copy from generated file

```c
// From generated_eoc_layouts.c
// eoc::BaseHpComponent - 8 bytes (0x8)
// Source: BaseHpComponent from Windows BG3SE
static const ComponentPropertyDef g_eoc_BaseHpComponent_Properties[] = {
    { "Vitality", 0x00, FIELD_TYPE_INT32, 0, false },
    { "VitalityBoost", 0x04, FIELD_TYPE_INT32, 0, false },
};
static const ComponentLayoutDef g_eoc_BaseHpComponent_Layout = {
    .componentName = "eoc::BaseHpComponent",
    .shortName = "BaseHpComponent",
    .componentTypeIndex = 0,
    .componentSize = 0x8,
    .properties = g_eoc_BaseHpComponent_Properties,
    .propertyCount = sizeof(g_eoc_BaseHpComponent_Properties) / sizeof(g_eoc_BaseHpComponent_Properties[0]),
};
```

### 2. Add to component_offsets.h

Paste into the file after existing layouts.

### 3. Register in array

```c
static const ComponentLayoutDef* g_AllComponentLayouts[] = {
    // ... existing ...
    &g_eoc_BaseHpComponent_Layout,
    NULL
};
```

### 4. Find TypeId

Check `src/entity/component_typeid.c` or extract from binary:

```bash
nm -gU "/path/to/BG3" | c++filt | grep "BaseHpComponent.*TypeIdContext"
# Returns: 0x1234567890 - BaseHpComponent TypeId address
```

### 5. Test in-game

```lua
local player = Ext.Entity.Get(Osi.GetHostCharacter())
local hp = player.BaseHp

_P("Vitality:", hp.Vitality)
_P("VitalityBoost:", hp.VitalityBoost)

-- Modify (if writable)
hp.VitalityBoost = 5
_P("New boost:", player.BaseHp.VitalityBoost)
```

### 6. Mark as verified

Add comment in component_offsets.h:

```c
// eoc::BaseHpComponent - 8 bytes (0x8) [VERIFIED 2025-12-24]
```

## Next Steps After Integration

1. **Update component count** in CLAUDE.md and README.md
2. **Document commonly used components** in agent_docs/
3. **Create mod examples** using new components
4. **Generate more namespaces** (esv::, ecl::, ls::) using same process
5. **Automate verification** with comprehensive test suite

## References

- Generated layouts: `ghidra/offsets/staging/generated_eoc_layouts.c`
- Component sizes: `ghidra/offsets/components/COMPONENT_SIZES_EOC_*.md`
- Windows headers: `/Users/tomdimino/Desktop/Programming/bg3se/BG3Extender/GameDefinitions/Components/`
- Integration target: `src/entity/component_offsets.h`
- TypeId definitions: `src/entity/component_typeid.c`
